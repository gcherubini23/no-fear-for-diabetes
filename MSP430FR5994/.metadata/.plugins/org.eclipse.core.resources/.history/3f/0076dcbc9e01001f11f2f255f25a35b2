#include <msp430.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include "driverlib.h"
#include "memory_util.h"
#include "model.h"
#include "config.h"


void arrayScalarMultiply(float* vec, int length, float scalar) {
    int i;
    for (i = 0; i < length; i++) {
        vec[i] *= scalar;
        }
    }

void arrayAddInPlace(float* vec1, const float* vec2, int length, bool make_non_negative) {
    int i;
    for (i = 0; i < length; i++) {
            vec1[i] += vec2[i];
            if ((make_non_negative) && (vec1[i] < 0)) {
                vec1[i] = 0;
                }
            }
}

float arrayMultiply(const float* vec1, const float* vec2, int length) {
    int i;
    float sum = 0;
    for (i = 0; i < length; i++) {
        sum += vec1[i] * vec2[i];
    }
    return sum;
}

void transpose(int n, int m, float A[n][m], float At[m][n]) {
    int i, j;
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            At[j][i] = A[i][j];
        }
    }
}

void matMult(int n, int k, int m, float A[n][k], float B[k][m], float C[n][m]) {
    int i, j, l;
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
//            C[i][j] = 0;
            for (l = 0; l < k; l++) {
                C[i][j] += A[i][l] * B[l][j];
            }
        }
    }
}

//void matAdd(int n, int m, double A[n][m], double B[n][m], double C[n][m]) {
//    for (int i = 0; i < n; i++) {
//        for (int j = 0; j < m; j++) {
//            C[i][j] = A[i][j] + B[i][j];
//        }
//    }
//}

void euler_solve(float x[STATE_SPACE], const float u[INPUT_SPACE], float y[EXTRA_STATE_SPACE], float v[MODEL_INPUT_SPACE], float dt, const float params[NUM_PARAMS]) {
    preprocess(x, u, y, v, dt);
    float dx_dt[STATE_SPACE];
    step(x, y, v, dx_dt, params);
    arrayScalarMultiply(dx_dt, STATE_SPACE, dt);
    arrayAddInPlace(x, dx_dt, STATE_SPACE, TRUE);
}

